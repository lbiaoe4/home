<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bracket 32 Seeds (Tree)</title>
  <style>
    :root{
      /* LBI vibe: claro + azul */
      --bg:#f6f9ff;
      --panel:#ffffff;
      --ink:#0b1220;
      --muted:rgba(11,18,32,.68);
      --line:rgba(11,18,32,.12);
      --line2:rgba(11,18,32,.08);
      --win:#16a34a;
      --lose:#e11d48;

      /* “zoom” global (0.8 = 80%) */
      --uiScale: .80;

      /* dimensões (ajuste fino aqui) */
      --colW: 320px;
      --boxH: 52px;
      --boxPad: 10px;
      --gapR1: 12px;
      --radius: 14px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1100px 650px at 20% 10%, rgba(37,99,235,.14), transparent 55%),
        radial-gradient(900px 550px at 85% 30%, rgba(99,102,241,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      overflow:hidden;
    }

    header{
      height:64px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 18px;
      border-bottom:1px solid var(--line);
      background: rgba(255,255,255,.70);
      backdrop-filter: blur(10px);
    }
    .title{
      display:flex; align-items:center; gap:10px;
      font-weight:900; letter-spacing:.3px;
    }
    .badge{
      font-size:12px;
      padding:4px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      color:var(--muted);
      background: rgba(255,255,255,.60);
    }
    .meta{
      display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12px;
    }
    .btn{
      cursor:pointer;
      border:1px solid var(--line);
      background: rgba(255,255,255,.65);
      color:var(--ink);
      padding:8px 12px;
      border-radius:12px;
      font-weight:900;
    }
    .btn:hover{ background: rgba(255,255,255,.92); }

    main{
      height: calc(100% - 64px);
      padding: 12px;
    }

    /* palco do bracket (aplica o zoom 80% estilo Chrome) */
    .stage{
      position:relative;
      border:1px solid var(--line);
      border-radius: 18px;
      background: linear-gradient(to bottom, rgba(255,255,255,.75), rgba(255,255,255,.40));
      overflow:hidden;

      transform: scale(var(--uiScale));
      transform-origin: top left;

      width: calc(100% / var(--uiScale));
      height: calc(100% / var(--uiScale));
    }

    .bracket{
      position:absolute;
      inset:0;
      padding: 14px;
    }

    svg#wires{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    .round{
      position:absolute;
      top: 14px;
      width: var(--colW);
      height: calc(100% - 28px);
    }
    .r-title{
      font-size:13px;
      font-weight:900;
      letter-spacing:.4px;
      color: var(--muted);
      margin: 0 0 10px 0;
      padding: 0 2px;
    }

    .match{
      position:absolute;
      width: var(--colW);
      height: var(--boxH);
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: linear-gradient(to bottom, rgba(255,255,255,.96), rgba(255,255,255,.72));
      box-shadow: 0 12px 30px rgba(11,18,32,.10);
      overflow:visible; /* tooltip pode sair pra fora */
    }

    /* BYE: some a pill sem mover nada */
    .match.isBye{
      visibility: hidden;       /* ocupa o espaço, mas some */
      pointer-events: none;     /* não interage */
    }

    .m-top{
      height: 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 6px var(--boxPad) 0;
      color: var(--muted);
      font-size: 11px;
    }
    .chip{
      font-size:11px;
      font-weight:900;
      color: var(--ink);
      padding: 2px 8px;
      border-radius: 999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.06);
    }

    .m-body{
      height: calc(var(--boxH) - 18px);
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      gap:10px;
      padding: 0 var(--boxPad);
    }
    .p{
      min-width:0;
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:900;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .vs{
      color: var(--muted);
      font-weight:900;
      font-size:11px;
      letter-spacing:.35px;
      opacity:.9;
      user-select:none;
    }

    .win{
      outline: 1px solid rgba(22,163,74,.40);
      box-shadow:
        0 0 0 1px rgba(22,163,74,.16) inset,
        0 12px 35px rgba(22,163,74,.10);
    }
    .win .chip{ border-color: rgba(22,163,74,.35); }
    .winmark{
      width: 8px; height: 8px; border-radius: 99px;
      background: rgba(22,163,74,.90);
      box-shadow: 0 0 0 3px rgba(22,163,74,.15);
      flex: 0 0 auto;
    }

    .foot{
      position:absolute;
      left:14px;
      bottom:12px;
      right:14px;
      display:flex;
      justify-content:space-between;
      color: var(--muted);
      font-size:11px;
      opacity:.95;
    }
    .warn{ color: #b45309; font-weight:900; }

    /* Tooltip do draft (imagem) – abre pro lado */
    .draftTip{
      position:absolute;
      top: 50%;
      left: calc(100% + 14px);
      transform: translateY(-50%);
      z-index: 80;

      width: 800px;
      max-width: 85vw;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.96);
      box-shadow: 0 18px 40px rgba(11,18,32,.16);
      display:none;
    }
    .draftTip img{
      width:100%;
      height:auto;
      display:block;
      border-radius: 12px;
      border: 1px solid var(--line2);
    }
    .draftTip .cap{ display:none; }

    .draftBtn{
      cursor:pointer;
      font-size:11px;
      font-weight:900;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.05);
      color: var(--ink);
      user-select:none;
    }
    .draftBtn:hover{ background: rgba(0,0,0,.08); }
    .match.hasDraft:hover .draftTip{ display:block; }

    /* flip automático para esquerda */
    .match.tipLeft .draftTip{
      left: auto;
      right: calc(100% + 14px);
    }

    @media (max-width: 1700px){
      :root{ --colW: 300px; --boxH: 50px; --gapR1: 10px; }
    }
    @media (max-width: 1500px){
      :root{ --colW: 280px; --boxH: 48px; --gapR1: 9px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <span>IMBR : BRACKET</span>
      <span class="badge">32 seeds • árvore R1–R5</span>
    </div>
    <div class="meta">
      <span id="last">Carregando…</span>
      <button class="btn" id="reload">Atualizar</button>
    </div>
  </header>

  <main>
    <div class="stage" id="stage">
      <svg id="wires"></svg>

      <div class="bracket" id="bracket">
        <div class="round" id="round1"><div class="r-title">Rodada 1 (32 → 16)</div></div>
        <div class="round" id="round2"><div class="r-title">Rodada 2 (16 → 8)</div></div>
        <div class="round" id="round3"><div class="r-title">Rodada 3 (8 → 4)</div></div>
        <div class="round" id="round4"><div class="r-title">Rodada 4 (4 → 2)</div></div>
        <div class="round" id="round5"><div class="r-title">Rodada 5 (Final)</div></div>

        <div class="foot">
          <span id="hint"></span>
          <span>Auto-update: 20s</span>
        </div>
      </div>
    </div>
  </main>

  <script>
    // ==== Fonte (sua planilha publicada) ====
    const PUBHTML_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTihzZmyAJhTVjALmuX1R1YTGyuW0p-5umWppci2rQVRMJ5h1m2IrkZo4wi4MUN_fZ03vxu2vwFT2ob/pubhtml?gid=1150926553&single=true";
    const CSV_URL = PUBHTML_URL.replace("/pubhtml", "/pub").replace(/(\?|&)single=true/g, "") + "&output=csv&single=true";

    function csvUrlNoCache(){
      return CSV_URL + "&t=" + Date.now();
    }

    // mapeamento por linhas (sem header)
    const ranges = {
      r1: [0,15],    // linhas 2..17
      r2: [16,23],   // 18..25
      r3: [24,27],   // 26..29
      r4: [28,29],   // 30..31
      r5: [30,30],   // 32
    };
    const expectedMatches = 31;

    const bracket = document.getElementById("bracket");
    const wires = document.getElementById("wires");
    const last = document.getElementById("last");
    const hint = document.getElementById("hint");

    const roundsEls = [
      document.getElementById("round1"),
      document.getElementById("round2"),
      document.getElementById("round3"),
      document.getElementById("round4"),
      document.getElementById("round5"),
    ];

    function nowStr(){
      const d = new Date();
      return d.toLocaleString("pt-BR", { hour12:false });
    }

    function parseCSV(text){
      const rows = [];
      let cur = [], field = "", inQuotes = false;
      for (let i=0; i<text.length; i++){
        const c = text[i], next = text[i+1];
        if (c === '"'){
          if (inQuotes && next === '"'){ field += '"'; i++; }
          else inQuotes = !inQuotes;
        } else if (c === ',' && !inQuotes){
          cur.push(field); field = "";
        } else if ((c === '\n' || c === '\r') && !inQuotes){
          if (c === '\r' && next === '\n') i++;
          cur.push(field); rows.push(cur);
          cur = []; field = "";
        } else field += c;
      }
      if (field.length || cur.length){ cur.push(field); rows.push(cur); }
      return rows.filter(r => r.some(x => String(x).trim() !== ""));
    }

    function normalizeHeaders(headerRow){
      const map = {};
      headerRow.forEach((h, idx) => map[String(h).trim().toLowerCase()] = idx);
      const idx = (name, fall=[]) => {
        if (map[name] !== undefined) return map[name];
        for (const f of fall) if (map[f] !== undefined) return map[f];
        return -1;
      };
      return {
        id: idx("id", ["pos"]),
        type: idx("type"),
        p1: idx("player1"),
        p2: idx("player2"),
        draft: idx("draft"),
        s1: idx("score1"),
        s2: idx("score2"),

        // tenta achar por header; se não existir, cai no fallback "coluna F" (índice 5)
        draft_img: idx("draft_img", ["draftimage","draft_image","image","img","link","draft_link"]),

        winner: idx("winner"),
      };
    }

    function pickCell(row, idx, fallbackIdx){
      if (idx >= 0) return row[idx] ?? "";
      if (fallbackIdx !== undefined && fallbackIdx >= 0) return row[fallbackIdx] ?? "";
      return "";
    }

    async function loadViaCSV(){
      const res = await fetch(csvUrlNoCache(), {
        cache: "no-store",
        headers: { "pragma":"no-cache", "cache-control":"no-cache" }
      });
      if (!res.ok) throw new Error("CSV fetch falhou");
      const txt = await res.text();
      const table = parseCSV(txt);
      const H = normalizeHeaders(table[0]);
      const body = table.slice(1);

      return body.map(row => ({
        id: pickCell(row, H.id),
        type: pickCell(row, H.type),
        player1: pickCell(row, H.p1),
        player2: pickCell(row, H.p2),
        draft: pickCell(row, H.draft),
        score1: pickCell(row, H.s1),
        score2: pickCell(row, H.s2),

        // fallback "coluna F" = índice 5 (0-based)
        draft_img: pickCell(row, H.draft_img, 5),

        winner: pickCell(row, H.winner),
      }));
    }

    // fallback (se CSV bloquear por CORS)
    async function loadViaPubHtml(){
      const res = await fetch(PUBHTML_URL + "&t=" + Date.now(), { cache:"no-store" });
      if (!res.ok) throw new Error("pubhtml fetch falhou");
      const html = await res.text();
      const doc = new DOMParser().parseFromString(html, "text/html");
      const table = doc.querySelector("table");
      if (!table) throw new Error("não achei tabela no pubhtml");
      const rows = [...table.querySelectorAll("tr")].map(tr =>
        [...tr.querySelectorAll("th,td")].map(td => td.textContent.trim())
      ).filter(r => r.length);

      const H = normalizeHeaders(rows[0]);
      const body = rows.slice(1);

      return body.map(row => ({
        id: pickCell(row, H.id),
        type: pickCell(row, H.type),
        player1: pickCell(row, H.p1),
        player2: pickCell(row, H.p2),
        draft: pickCell(row, H.draft),
        score1: pickCell(row, H.s1),
        score2: pickCell(row, H.s2),

        // fallback "coluna F" = índice 5 (0-based)
        draft_img: pickCell(row, H.draft_img, 5),

        winner: pickCell(row, H.winner),
      }));
    }

    async function loadAll(){
      try { return await loadViaCSV(); }
      catch { return await loadViaPubHtml(); }
    }

    function sliceMatches(all, a, b){ return all.slice(a, b+1); }
    function winnerOf(m){ return String(m.winner||"").trim(); }

    function isBye(m){
      const s1 = parseInt(String(m.score1||"").trim(), 10);
      const s2 = parseInt(String(m.score2||"").trim(), 10);
      return (s1 === 99 && s2 === 0) || (s1 === 0 && s2 === 99);
    }

    function normalizeImgUrl(url){
      const u = String(url||"").trim();
      if (!u) return "";
      if (/\.(png|jpg|jpeg|webp|gif)(\?.*)?$/i.test(u)) return u;

      const m = u.match(/drive\.google\.com\/file\/d\/([^/]+)\//i);
      if (m && m[1]) return `https://drive.google.com/uc?export=view&id=${m[1]}`;

      return u;
    }

    function makeMatchEl(m){
      const el = document.createElement("div");
      el.className = "match";
      el.dataset.id = String(m.id||"").trim();

      if (isBye(m)) el.classList.add("isBye");

      const w = winnerOf(m);
      const p1 = String(m.player1||"").trim();
      const p2 = String(m.player2||"").trim();
      const p1Win = w && w === p1;
      const p2Win = w && w === p2;

      if (w) el.classList.add("win");

      const chipText = (m.id || "—");
      const typeText = (m.type || "");

      // ✅ não mostra o campo "draft" como texto (evita vazar URL na pill)
      const rightTopBase = typeText || "";

      const img = normalizeImgUrl(m.draft_img);
      const hasImg = !!img;
      if (hasImg) el.classList.add("hasDraft");

      const scoreShown = (String(m.score1||"").trim() !== "" || String(m.score2||"").trim() !== "")
        ? `${m.score1||"0"}–${m.score2||"0"}`
        : "VS";

      el.innerHTML = `
        <div class="m-top">
          <span class="chip">${chipText}</span>
          <span style="display:flex; gap:8px; align-items:center;">
            <span>${rightTopBase}</span>
            ${hasImg ? `<span class="draftBtn" title="Ver draft">Draft</span>` : ``}
          </span>
        </div>

        <div class="m-body">
          <div class="p" title="${p1}">
            ${p1Win ? '<span class="winmark"></span>' : ''}
            <span style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${p1 || "—"}</span>
          </div>
          <div class="vs">${scoreShown}</div>
          <div class="p" style="justify-content:flex-end;text-align:right" title="${p2}">
            <span style="min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${p2 || "—"}</span>
            ${p2Win ? '<span class="winmark"></span>' : ''}
          </div>
        </div>

        ${hasImg ? `
          <div class="draftTip">
            <img src="${img}" alt="Draft da partida" loading="lazy" />
          </div>
        ` : ``}
      `;

      return el;
    }

    function padTo(arr, n){
      while(arr.length < n){
        arr.push({id:"",type:"",player1:"",player2:"",draft:"",score1:"",score2:"",winner:"",draft_img:""});
      }
      return arr;
    }

    // decide se o tooltip vai pra esquerda quando faltar espaço
    function applyTooltipFlip(){
      const margin = 18;
      document.querySelectorAll(".match.hasDraft").forEach(el => {
        el.classList.remove("tipLeft");
        const tip = el.querySelector(".draftTip");
        if (!tip) return;

        const r = el.getBoundingClientRect();
        const spaceRight = window.innerWidth - r.right - margin;
        const tipW = tip.offsetWidth || 800;

        if (spaceRight < tipW) el.classList.add("tipLeft");
      });
    }

    function layout(rounds){
      roundsEls.forEach(r => [...r.querySelectorAll(".match")].forEach(n => n.remove()));
      wires.innerHTML = "";

      const css = getComputedStyle(document.documentElement);
      const colW = parseFloat(css.getPropertyValue("--colW"));
      const boxH = parseFloat(css.getPropertyValue("--boxH"));
      const gapR1 = parseFloat(css.getPropertyValue("--gapR1"));

      const padX = 14;
      const topY = 14 + 26;
      const usableH = bracket.clientHeight - 14 - 12 - 26 - 20;

      const totalW = (colW * 5) + (36 * 4);
      const startX = Math.max(padX, (bracket.clientWidth - totalW)/2);
      const gapX = 36;

      roundsEls.forEach((col, i)=>{
        col.style.left = (startX + i*(colW+gapX)) + "px";
      });

      const r1Count = rounds[0].length;
      const r1Total = (r1Count * boxH) + ((r1Count - 1) * gapR1);
      const baseY = Math.max(topY, topY + (usableH - r1Total)/2);

      const nodes = [[],[],[],[],[]];

      for (let i=0;i<r1Count;i++){
        const el = makeMatchEl(rounds[0][i]);
        const y = baseY + i*(boxH+gapR1);
        el.style.top = y + "px";
        roundsEls[0].appendChild(el);
        nodes[0].push(el);
      }

      for (let r=1; r<5; r++){
        for (let i=0;i<rounds[r].length;i++){
          const child1 = nodes[r-1][i*2];
          const child2 = nodes[r-1][i*2+1];
          const y = (((parseFloat(child1.style.top)||0) + (parseFloat(child2.style.top)||0)) / 2);
          const boxHlocal = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--boxH"));
          const el = makeMatchEl(rounds[r][i]);
          el.style.top = (y) + "px";
          roundsEls[r].appendChild(el);
          nodes[r].push(el);
        }
      }

      return nodes;
    }

    // SVG wires corrigidos pro SCALE (zoom 80%) + pular BYE
    function drawWires(nodes){
      wires.innerHTML = "";

      const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--uiScale")) || 1;
      wires.setAttribute("viewBox", `0 0 ${bracket.clientWidth} ${bracket.clientHeight}`);

      const bracketRect = bracket.getBoundingClientRect();

      function centerPoint(el, side){
        const r = el.getBoundingClientRect();
        const xVisual = (side === "left") ? (r.left - bracketRect.left) : (r.right - bracketRect.left);
        const yVisual = (r.top - bracketRect.top) + (r.height/2);
        return { x: xVisual / scale, y: yVisual / scale };
      }

      const stroke  = "rgba(11,18,32,.20)";
      const stroke2 = "rgba(11,18,32,.12)";

      for (let r=1; r<5; r++){
        for (let i=0;i<nodes[r].length;i++){
          const parent = nodes[r][i];
          const child1 = nodes[r-1][i*2];
          const child2 = nodes[r-1][i*2+1];

          // ✅ se algum “filho” é BYE (pill escondida), não desenha conectores desse par
          if (!child1 || !child2) continue;
          if (child1.classList.contains("isBye") || child2.classList.contains("isBye")) continue;

          const pL  = centerPoint(parent, "left");
          const c1R = centerPoint(child1, "right");
          const c2R = centerPoint(child2, "right");

          const midX = (c1R.x + pL.x) / 2;

          const d  = `M ${c1R.x} ${c1R.y} L ${midX} ${c1R.y} L ${midX} ${c2R.y} L ${c2R.x} ${c2R.y}`;
          const d2 = `M ${midX} ${(c1R.y+c2R.y)/2} L ${pL.x} ${pL.y}`;

          const path = document.createElementNS("http://www.w3.org/2000/svg","path");
          path.setAttribute("d", d);
          path.setAttribute("fill","none");
          path.setAttribute("stroke", stroke2);
          path.setAttribute("stroke-width","2");
          path.setAttribute("stroke-linecap","round");
          path.setAttribute("stroke-linejoin","round");

          const path2 = document.createElementNS("http://www.w3.org/2000/svg","path");
          path2.setAttribute("d", d2);
          path2.setAttribute("fill","none");
          path2.setAttribute("stroke", stroke);
          path2.setAttribute("stroke-width","2");
          path2.setAttribute("stroke-linecap","round");
          path2.setAttribute("stroke-linejoin","round");

          wires.appendChild(path);
          wires.appendChild(path2);
        }
      }
    }

    async function loadAndRender(){
      try{
        const all = await loadAll();

        if (all.length < expectedMatches){
          hint.innerHTML = `<span class="warn">Aviso: achei ${all.length}/${expectedMatches} partidas. Confere se publicou as 31 linhas.</span>`;
        } else {
          hint.textContent = `Fonte: planilha publicada • ${expectedMatches} partidas`;
        }

        const r1 = padTo(sliceMatches(all, ...ranges.r1), 16);
        const r2 = padTo(sliceMatches(all, ...ranges.r2), 8);
        const r3 = padTo(sliceMatches(all, ...ranges.r3), 4);
        const r4 = padTo(sliceMatches(all, ...ranges.r4), 2);
        const r5 = padTo(sliceMatches(all, ...ranges.r5), 1);

        const nodes = layout([r1,r2,r3,r4,r5]);

        // desenha wires depois do layout estabilizar
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            drawWires(nodes);
            applyTooltipFlip();
          });
        });

        last.textContent = `Atualizado: ${nowStr()}`;
      }catch(err){
        console.error(err);
        hint.innerHTML = `<span class="warn">Não consegui ler a planilha (CORS/cache).</span>`;
        last.textContent = `Erro ao carregar`;
      }
    }

    document.getElementById("reload").addEventListener("click", loadAndRender);

    loadAndRender();
    setInterval(loadAndRender, 20000);

    let resizeTimer = null;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(loadAndRender, 160);
    });
  </script>
</body>
</html>
